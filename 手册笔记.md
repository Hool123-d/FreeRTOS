![image-20250522165008660](./手册笔记/image-20250522165008660.png)



# 2.FreeRTOS内核描述

## 2.2 理解FreeRTOS文件分配

​	主要针对每个文件的内容和功能进行了介绍。

### 2.2.3 FreeRTOSConfig.h

​	该头文件中配置了对常量进行了宏定义。官方建议，引用时不要引用该文件，应该引用freeRTOS.h

### 2.2.7 

​	官方建议，可以下载单独的文件，但是最好下载整个发行版

## 2.5 数据类型和codeing 风格

**TickType_t：**FreeRTOS配置一个称为“滴答”中断的周期性中断。记录，中断的次数，用于计时。

### 3. 堆内存管理

### **3.1.2：Scope**

​	1.什么时候FreeRTOS分配RAM

​	2.FreeRTOS支持的5个内存分配计划的案例

​	3.选择哪个内存分配方案？

### 3.1.3 动态分配和静态分配切换

​	以下章节介绍了内核对象，如任务、队列、信号量和事件组。这些对象所需的内存可以在编译时静态分配，也可以在运行时动态分配。动态分配减少了设计和规划的工作量，简化了API，并最小化了内存占用。静态分配更加确定性，消除了处理内存分配失败的需求，并消除了堆碎片的风险（即堆有足够的空闲内存但不是连续可用的块）。

​	动态分配内存前置条件要在FreeRTOSConfig.h中configSUPPORT_STATIC_ALLOCATION 置为1



# 4.内存管理

## 4.1.1 Scope

​	1.FreeRTOS如何为应用程序中的每个任务分配处理时间。
​	2.FreeRTOS如何在任何特定时刻决定由哪个任务执行。
​	3.每个任务的相对优先级如何影响系统的运行情况。
​	4.任务可能存在的状态。

包括以下内容：

​	1.如何执行任务。
​	2.如何创建一个或多个任务实例。
​	3.如何使用任务参数。
​	4.如何更改已创建任务的优先级。
​	5.如何删除一项任务。
​	6.如何通过任务来实现周期性处理。（后续章节将介绍如何通过软件定时器来实现同样的功能。
​	7.闲置任务何时会执行以及如何使用该任务。



## 4.2 Task Functions

```c
void vATaskFunction( void * pvParameters )；
```

任务函数是执行我们程序的函数，正常情况下应当无限循环，并且不会退出(return)，但是它可以删除自己。delete(null);

## 4.3 Top Level Task States

 **注意**  这里说的是简化后的状态，详细的后面会展开介绍

![image-20250522210713260](./手册笔记/image-20250522210713260.png)

## 4.4 Task Creation

​	**有6个API能够重建任务:** xTaskCreate(), xTaskCreateStatic(),

xTaskCreateRestricted(), xTaskCreateRestrictedStatic(), xTaskCreateAffinitySet(), and xTaskCreateStaticAffinitySet()

​	每个任务需要两个RAM块：一个用于保存其任务控制块（Task Control Block **TCB**），带有“**Static**”前缀的FreeRTOS API函数使用预分配的内存块作为参数传递给函数。相反，没有“**Static**”前缀的API函数则在运行时从系统堆中**动态分配所需的内存**。

​	某些FreeRTOS API支持以“**restricted**”或“**unprivileged**”模式运行的任务。名称中带有“**restricted**”的FreeRTOS API函数创建的任务具有有限的系统内存访问权限。名称中不带“**restricted**”的API函数创建的任务则以“**privileged**模式”运行，并拥有对整个系统内存映射的访问权限。

​	支持对称多处理（Symmetric Multi Processing **SMP**）的FreeRTOS API允许在同一个CPU的多个内核上同时运行不同的任务。您可以使用名称中带有“**Affinity**”的函数来指定任务将在哪个内核上运行。

​	FreeRTOS任务创建API函数相当复杂。本文档中的大多数示例都使用**xTaskCreate（），因为它是这些函数中最简单的。**

### 4.4.1 The xTaskCreate() API Function

```c
BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, 
 const char * const pcName, 
 configSTACK_DEPTH_TYPE usStackDepth, 
 void * pvParameters, 
 UBaseType_t uxPriority, 
 TaskHandle_t * pxCreatedTask );
```

**xTaskCreate() Parameters and return value:**

**pvTaskCode**

​	Tasks are simply C functions that never exit and, as such, are normally implemented as an infinite loop. The pvTaskCode parameter is simply a pointer to the function that implements the task (in effect, just the function's name).

**pcName**

​	A descriptive name for the task. FreeRTOS does not use this in any way and it is included purely as a debugging aid. Identifying a task by a human-readable name is much simpler than identifying it by its handle.

​	The application-defined constant configMAX_TASK_NAME_LEN defines the maximum length a task namecan be, including the NULL terminator. Supplying a longer string results in the string being truncated.

**usStackDepth**

​	Specifies the size of the stack to allocate for use by the task. Use xTaskCreateStatic() instead ofxTaskCreate() to use pre-allocated memory instead of dynamically allocated memory.

​	**注意**，该值指定栈可以容纳的 **字** 数，而不是字节数。例如，如果栈为32位宽且usStackDepth为128，则xTaskCreate（）分配512字节的栈空间(128 * 4字节）。

​	configSTACK_DEPTH_TYPE是一个宏，允许应用程序编写者指定用于保存栈大小的数据类型。如果未定义，则configSTACK_DEPTH_TYPE默认为uint16_t。

**pvParameters**

​	Functions that implement tasks accept a single void pointer (void *) parameter. pvParameters is thevalue passed into the task using that parameter.

**uxPriority**

​	Defines the task's priority. 0 is the lowest priority and (configMAX_PRIORITIES – 1) is the highestpriority. Section 4.5 describes the user defined configMAX_PRIORITIES constant.

​	If a uxPriority greater than (configMAX_PRIORITIES – 1) is defined, it will be capped to(configMAX_PRIORITIES – 1).

**pxCreatedTask**

​	Pointer to a location to store a handle to the created task. This handle may be used in future API calls to,for example, change the task's priority or delete the task.

​	pxCreatedTask is an optional parameter and may be set to NULL if the task's handle is not required.

**Return values**

​	There are two possible return values:

**pdPASS**

​	This indicates the task was created successfully.

**pdFAIL**

​	This indicates there was not enough heap memory available to create the task. Chapter 3 provides more information on heap memory management.

**举例：**

```c
int main( void )
{ 
 /* 
 * Variables declared here may no longer exist after starting the FreeRTOS
 * scheduler. Do not attempt to access variables declared on the stack used
 * by main() from tasks. 
 */
 /* 
 * Create one of the two tasks. Note that a real application should check
 * the return value of the xTaskCreate() call to ensure the task was
 * created successfully. 
 */
 xTaskCreate( vTask1, /* Pointer to the function that implements the task.*/
 "Task 1",/* Text name for the task. */
 1000, /* Stack depth in words. */
 NULL, /* This example does not use the task parameter. */
 1, /* This task will run at priority 1. */
 NULL ); /* This example does not use the task handle. */
 /* Create the other task in exactly the same way and at the same priority.*/
 xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL ); 
 /* Start the scheduler so the tasks start executing. */
 vTaskStartScheduler(); 
 /* 
 * If all is well main() will not reach here because the scheduler will now
 * be running the created tasks. If main() does reach here then there was
 * not enough heap memory to create either the idle or timer tasks
 * (described later in this book). Chapter 3 provides more information on
 * heap memory management. 
 */
 for( ;; ); 
}
```

随时间变化的任务执行情况：

![image-20250522220224659](./手册笔记/image-20250522220224659.png)

任务可以创建在main()内，也可以创建在其他函数中，如下：

```c
void vTask1( void * pvParameters )
{ 
 const char *pcTaskName = "Task 1 is running\r\n"; 
 volatile unsigned long ul; /* volatile to ensure ul is not optimized away. */
 /* 
 * If this task code is executing then the scheduler must already have
 * been started. Create the other task before entering the infinite loop.
 */
 xTaskCreate( vTask2, "Task 2", 1000, NULL, 1, NULL ); 
 for( ;; ) 
 { 
 /* Print out the name of this task. */
 vPrintLine( pcTaskName ); 
 /* Delay for a period. */
 for( ul = 0; ul < mainDELAY_LOOP_COUNT; ul++ ) 
 { 
Mastering the FreeRTOS Real Time Kernel 43
 /* 
 * This loop is just a very crude delay implementation. There is
 * nothing to do in here. Later examples will replace this crude
 * loop with a proper delay/sleep function. 
 */
 } 
 } 
}
```

## 4.5 Taks Priority

​	FreeRTOS总是确保最高优先级的任务能够执行，如果优先级相同，那么同等优先级的任务将以时间片进行轮询 (依次转换“Running” 和 “out of Running”)。

​	用于创建任务的API函数的uxPriority参数为任务提供初始优先级。vTaskPrioritySet（）API函数在创建任务后更改任务的优先级。

​	应用程序定义的configMAX_PRIORITIES，在编译时设置可用优先级的数量。数值较低的优先级表示低优先级任务，其中优先级0是(可能的)最低优先级-因此有效优先级范围为0到（configMAX_PRIORITIES-1）。多个任务可以共享相同的优先级。

​	FreeRTOS调度程序有两种算法实现，用于选择运行状态任务。configMAX_PRIORITIES的最大允许值取决于所使用的算法：

### 4.5.1 Generic Scheduler

​	通用调度程序是用C语言编写的，可以与所有FreeRTOS架构端口一起使用。它对configMAX_PRIORITES没有设置上限。通常建议尽量减少configMAX_PRIORITIES，因为更多的值需要更多的RAM，并且会导致最坏情况下的执行时间更长。

### 4.5.2 Architecture-Optimized Scheduler

​	架构优化实现采用**特定于架构的汇编**代码编写，性能优于通用c实现，且所有configMAX_PRIORITIES值的最坏情况执行时间相同。

​	优化的体系结构实现对32位体系结构的configMAX_PRIORITIES的最大值为32，对64位体系结构的最大值为64。与**Generic Scheduler**方法一样，建议将configMAX_PRIORITIES保持在实际可行的最低值，因为更高的值需要更多的RAM。

​	在FreeRTOSConfig.h中将configUSE_PORT_optimized_TASK_SELECTION设置为1以使用**Architecture-Optimized Scheduler**的实现，或设置为0以使用**Generic Scheduler**实现。并非所有FreeRTOS端口都有架构优化的实现。那些有**Architecture-Optimized Scheduler**实现的端口，默认情况下如果未定义，则将configUSE_PORT_optimized_TASK_SELECTION默认设置为1。那些没有**Architecture-Optimized Scheduler**实现的端口，默认情况下如果未定义，则将configUSE_PORT_optimized_TASK_SELECTION默认设置为0。



## 4.6 Time Measurement and the Tick Interrupt

​	**Section 4.12, Scheduling Algorithms**，描述了一个名为“时间切片”的可选功能。

​	调度器在每个时间片结束时执行，以选择下一个要运行的任务n[^5].。为此，使用了一个称为“**tick interrupt**”的周期性中断。**configTICK_RATE_HZ**编译时配置常量设置了滴答中断的频率，因此也决定了每个时间片的长度。例如，将configTICK_RATE_HZ设置为100（Hz）会导致每个时间片持续10毫秒。两个中断之间的间隔称为“周期”——因此一个时间片等于一个周期。

> [^5]：需要注意的是，时间片结束并不是调度器选择新任务运行的唯一时机。正如本书将要展示的那样，当当前执行的任务进入阻塞状态后，或者中断将更高优先级的任务移至就绪状态时，调度器也会立即选择新的任务运行。

图4.4，展示了调度器的执行过程。最上方一行显示了调度器的执行时间，细箭头表示从任务到定时中断，再从定时中断回到另一个任务的执行顺序。

**configTICK_RATE_HZ的最佳值取决于应用程序，通常情况下为100 （也就是每个任时间片为10ms）。**

![image-20250522230252162](./手册笔记/image-20250522230252162.png)



​	FreeRTOS API 以滴答周期（tick periods）的倍数指定时间，通常简称为“滴答”（ticks）。pdMS_TO_TICKS() 宏用于将以毫秒为单位指定的时间转换为以滴答为单位的时间。可用的分辨率取决于定义的滴答频率，当滴答频率高于 1KHz（即 configTICK_RATE_HZ 大于 1000）时，无法使用 pdMS_TO_TICKS()。下面 展示了如何使用 pdMS_TO_TICKS() 将 200 毫秒的指定时间转换为等效的滴答时间

```c
TickType_t xTimeInTicks = pdMS_TO_TICKS( 200 );
```

​	

​	**使用pdMS_TO_TICKS（）将时间指定为毫秒**，而不是直接以滴答计数表示，可以确保应用程序中指定的时间不会因滴答频率的变化而改变。‘滴答计数(tick count')’是指自调度器启动以来发生的总滴答中断次数，前提是滴答计数未溢出。用户应用程序在指定延迟期间时无需考虑溢出问题，因为FreeRTOS在内部管理时间的一致性。

​	第4.12节： Scheduling Algorithms 描述了影响调度器何时选择新任务运行以及何时执行滴答中断的常量配置。

## 4.7 Expanding the *Not Running* State

​	到目前为止，创建的所有任务都能够执行某种行为，并且不需要等待任何事情（因为目前，只有运行和不运行状态），所以，他们都能进入运行状态。这种现实是因为所有的优先级都相同，这也使得任务的执行在某种程度上受到限制，CPU利用率下降。如果有一个更高优先级的任务，那么就会阻止这些任务的执行。

​	要使这些任务能够执行，必须将其重写为事件驱动的，而事件驱动的任务只有在事件触发后才被执行，在此之前不能进入运行状态。如果调度器因为高优先级的任务正在等待事件而无法选择执行，调度程序必须选择一个较低优先级的任务来运行。因此为任务设置为事件驱动任务可以在不同的优先级下创建任务，而不会让最高优先级的任务耗尽所有资源。

### 4.7.1 The *Blocked* State

​	非运行状态中的一个子状态为阻塞态(*Blocked State*)。当某个任务等待某个事件是，即为阻塞态。

任务可以进入阻塞状态，以等待两种不同类型的事件

​	1：时间相关事 (*Temporal (time-related) events*) ——这类事件在延迟周期结束或达到绝对时间时发生。例如，某项任务可能进入阻塞状态以等待10毫秒 (vTaksDelay())。

​	2：同步事件 (*Synchronization events*) ——这类事件源自其他任务或中断。例如，某个任务可能进入阻塞状态以等待队列数据 (xQueueTake())。同步事件涵盖了广泛的事件类型。

​	FreeRTOS队列、二进制信号量、计数信号量、互斥锁、递归互斥锁、事件组、流缓冲区、消息缓冲区以及直接任务通知都能创建同步事件。后续章节将涵盖这些功能的大部分内容。

​	任务可以在带有超时的同步事件上阻塞，同时对两种类型的事件进行阻塞。例如，某个任务可能选择最多等待10毫秒以接收队列数据。若在10毫秒内有数据到达，或10毫秒超时仍无数据到达，该任务都将解除阻塞状态。

### 4.7.2 The *Suspended* State

 	挂起 (*Suspended*) 状态也是非运行状态的一个子状态。调度器无法操作处于挂起状态的任务。进入挂起状态的唯一方式是通过调用vTaskSuspend() API函数，而退出的唯一途径则是通过调用vTaskResume()或xTaskResumeFromISR() API函数。大多数应用程序不会使用挂起状态。

### 4.7.3 The Ready State

​	处于非运行状态且未被阻塞或挂起的任务被称为就绪 (*Ready*) 状态。这些任务可以运行，但当前不处于运行状态，因此为“准备就绪”运行。

### 4.7.4 Completing the State Transition Diagram

​	下图包含了本节所述的所有"非运行"子状态。

<img src="./手册笔记/image-20250525105644219.png" alt="image-20250525105644219" style="zoom:50%;" />

​	任何形式的轮询都存在若干缺点，其中最突出的是效率低下。在轮询过程中，任务实际上没有任何工作要执行，却仍占用最大处理时间，从而浪费处理器周期。通过用vTaskDelay() API函数调用取代轮询空循环来修正这一行为，该函数原型如代码如下所示：需注意vTaskDelay() API函数仅在FreeRTOSConfig.h文件中将INCLUDE_vTaskDelay设置为1时可用。

```c
void vTaskDelay( TickType_t xTicksToDelay );
```

​	vTaskDelay()函数将调用任务置于阻塞状态，持续固定数量的Tick中断。该任务在阻塞状态下不会占用任何处理时间，因此仅当实际需要执行工作时才会消耗处理时间。

**vTaskDelay parameters:**

**xTicksToDelay**

​	The number of tick interrupts that the calling task will remain in the *Blocked* state before being transitionedback into the Ready state.

​	例如，如果一个任务调用vtaskdelay(100)，那么它将立即进入阻塞状态，并在100次tick中断后解除阻塞状态。

​	宏*pdMS_TO_TICKS()*可用于将指定的毫秒时间转换为Tick的时间 (某些时候Tick一次的时间不是 1 ms)。例如，在调用*vTaskDelay( pdMS_TO_TICKS(100))*，表明该任务将进入阻塞状态100毫秒。

```c
void vTaskFunction( void * pvParameters )
{ 
 char * pcTaskName; 
 const TickType_t xDelay250ms = pdMS_TO_TICKS( 250 ); 
 /* 
 * The string to print out is passed in via the parameter. Cast this to a
 * character pointer. 
 */
 pcTaskName = ( char * ) pvParameters; 
 /* As per most tasks, this task is implemented in an infinite loop. */
 for( ;; ) 
 { 
 /* Print out the name of this task. */
 vPrintLine( pcTaskName ); 
Mastering the FreeRTOS Real Time Kernel 54
 /* 
 * Delay for a period. This time a call to vTaskDelay() is used which
 * places the task into the Blocked state until the delay period has
 * expired. The parameter takes a time specified in 'ticks', and the
 * pdMS_TO_TICKS() macro is used (where the xDelay250ms constant is
 * declared) to convert 250 milliseconds into an equivalent time in
 * ticks. 
 */
 vTaskDelay( xDelay250ms ); 
 } 
}
```

​	图中执行顺序解释了为什么这两个任务即使在创建时优先级不同，仍然都能够执行。为简化起见，省略了调度程序本身的优先级。

​	当启动调度程序时，**会自动创建空闲 (*idle*)任务**，以确保始终至少有一个任务可以至少在就绪状态部分运行一个任务，*Section 4.8: The Idle Task and the Idle Task Hook*描述了空闲任务的详细信息

<img src="./手册笔记/image-20250525115417547.png" alt="image-20250525115417547" style="zoom:67%;" />

​	图4.4展示了当任务使用空循环制造延迟时始终能够运行的执行模式。其结果是，这些任务共同占用了处理器可用的全部时间。图4.9则展示了当任务在整个延迟期间进入阻塞状态时的执行模式。这些任务仅在确实需要执行时（本例中仅是打印一条消息）才会占用处理器时间，因此仅消耗了可用CPU处理时间的极小部分。

​	在图4.9所示的场景中，每当任务离开阻塞状态时，它们会执行一个时间片段的周期后重新进入阻塞状态。大多数情况下，系统没有可运行的应用程序任务（就绪状态中没有应用程序任务），因此也没有能被选中进入运行状态的应用程序任务。在这种情况下，**空闲任务**(调度器自动创建) 就会运行。分配给空闲任务的处理时间量，是衡量系统剩余处理能力的指标。通过采用实时操作系统（RTOS），仅需允许应用程序完全由事件驱动，就能显著提升系统的剩余处理能力。

​	图4.10中的粗线展示了上述案例中任务执行的转换过程，每个任务现在都会先经过阻塞状态，然后才返回到就绪状态。

<img src="./手册笔记/image-20250525134349967.png" alt="image-20250525134349967" style="zoom:50%;" />

### 4.7.5 The vTaskDelayUntil() API Function

​	vTaskDelayUntil()函数与vTaskDelay()类似。vTaskDelay()参数指定了从任务调用vTaskDelay()开始，到该任务从阻塞状态转换出来之间应该发生的Tick中断次数。	任务在阻塞状态中停留的时长(Tick次数)由vTaskDelay()参数指定，但任务离开阻塞状态的时间是**相对于调用vTaskDelay()的时刻而言的**。

​	vTaskDelayUntil()函数的参数指定的是调用任务应从阻塞状态转入就绪状态的Tick中断计数值。当需要以固定频率执行任务时，应使用vTaskDelayUntil()这个API函数，因为调用任务解除阻塞的时间是绝对时间，而非相对于函数被调用的时间（这与vTaskDelay()的情况不同）。

```c
void vTaskDelayUntil( TickType_t * pxPreviousWakeTime, 
					 TickType_t xTimeIncrement );
```

**vTaskDelayUntil() parameters**

**pxPreviousWakeTime**

​	This parameter is named on the assumption that vTaskDelayUntil() is being used to implement a task that executes periodically and with a fixed frequency. In this case, pxPreviousWakeTime holds the time at which the task last left the *Blocked* state (was 'woken' up). This time is used as a reference point to calculate the time at which the task should next leave the *Blocked* state.

​	The variable pointed to by pxPreviousWakeTime is updated automatically in the vTaskDelayUntil() function; it would not normally be modified by the application code, but must be initialized to the current tick count before its first use. Listing 4.15 demonstrates how to initialise the variable.

**xTimeIncrement**

​	This parameter is also named on the assumption that vTaskDelayUntil() is being used to implement a task that executes periodically and with a fixed frequency that is set by the xTimeIncrement value.

​	xTimeIncrement is specified in 'ticks'. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks.

当周期性执行的函数优先级比当前运行任务的优先级高时，才会立即切换任务。

![image-20250525140211492](./手册笔记/image-20250525140211492.png)

## 4.8 The Idle Task and the Idle Task Hook

​	处于阻塞态的任务不会被调度程序选中，因此无法运行。

​	调度器必须保证至少有一个任务处于运行态[^6]，为了保证这一点，调度器自动通过vTaskStartScheduler() API创建了空闲 (***idel***) 任务，空闲任务可以做的事情很少，但始终能够去运行，这保证了至少有一个任务处于运行态。

> [^6]即便在使用FreeRTOS特有的低功耗功能时也是如此——这种情况下，如果应用程序创建的所有任务均无法执行，运行FreeRTOS的微控制器将进入低功耗模式。

​	空闲任务的优先级是能够设置的最低优先级，这确保了它不会组织其他更好优先级任务进入运行态。但是，如果需要，程序员能够在创建任务时，将任务的优先级设置为与空闲任务相同的优先级。配置*FreeRTOSConfig.h*文件中的*configIDLE_SHOULD_YIELD*能够阻止空闲任务消耗CPU，从而将CPU更高效的分配给优先级为0的任务。

 	++：**注意：configIDLE_SHOULD_YIELD**设置为 1 时，表明空闲任务会实时检测，是否有相同优先级的任务处于就绪态，如果有就立即切换任务。

​		如果**configIDLE_SHOULD_YIELD** 设置为0，则空闲任务将和其他优先级为0的任务同等分配CPU资源，进行时间片轮询，这可能会导致任务的延迟执行。

​	Section 4.12, Scheduling Algorithms, 描述了configIDLE_SHOULD_YIELD。

​	空闲任务以最低优先级进入运行态，是为了确保当高优先级任务进入就绪态时，空闲任务能够从运行态中转换出来 (让出CPU) 。对CPU的抢占是自动发生的，而任务本身并不知道。

>注意：如果某个任务使用vTaskDelete() API函数删除自身 (自身或者NULL)，则必须确保空闲任务能够获得足够的处理时间。这是因为空闲任务负责清理被删除任务所使用的内核资源。

### 4.8.1 Idle Task Hook Functions

​	可以通过在空闲任务中使用空闲钩子（或空闲回调）函数，将特定应用功能直接添加到空闲任务中。该函数会在空闲任务循环的每次迭代中由空闲任务自动调用一次。

​	空闲任务常见钩子包括：

- 允许在空闲任务（优先级为 0）的上下文中执行低优先级、后台或持续运行的逻辑，无需创建额外的 FreeRTOS 任务，从而节省 RAM。

- 测量空闲处理能力的大小。（空闲任务仅在所有更高优先级的应用任务均无工作可执行时才会运行；因此，测量分配给空闲任务的处理时间量可清晰表明空闲处理时间的多少。）

- 将处理器置于低功耗模式，提供了一种简便且自动的省电方法，可在无应用处理任务执行时启用（尽管此模式下的节能效果不如无滴答空闲模式）。

### 4.8.2 Limitations on the Implementation of Idle Task Hook Functions

空闲任务钩子函数必须遵守以下规则：

- 空闲任务钩子函数禁止尝试进入阻塞或挂起态。

  ​	以任何方式阻塞空闲任务都可能导致没有任务能够进入运行状态的情况。

- 如果应用任务使用vTaskDelete() API函数删除自身，则空闲任务钩子必须始终在合理时间段内返回其调用方(空闲任务)。

​		这是因为空闲任务负责清理分配给自行删除任务的内核资源。如果空闲任务一直停留在空闲钩子函数中，那么这种清理就无法完成。

```c
void vApplicationIdleHook( void );
```

## 4.9 Changing the Priority of a Task

### 4.9.1 The vTaskPrioritySet() API Function

​	在将FreeRTOSConfig.h文件中的vTaskPrioritySet 设置为1后，*vTaskPrioritySet()* API 函数允许在调度器开始运行之后修改任务的优先级。

```c
void vTaskPrioritySet( TaskHandle_t xTask, 
					 UBaseType_t uxNewPriority );
```

**pxTask**

​	The handle of the task whose priority is being modified (the subject task). See the pxCreatedTask parameter of the xTaskCreate() API function, or the return value of the xTaskCreateStatic() API function, for information on obtaining handles to tasks.

​	A task can change its own priority by passing NULL in place of a valid task handle. 

**uxNewPriority**

​	The priority to which the subject task is to be set. This is capped automatically to the maximum available priority of (configMAX_PRIORITIES – 1), where configMAX_PRIORITIES is a compile time constant set in the FreeRTOSConfig.h header file.

### 4.9.2 The uxTaskPriorityGet() API Function

​	uxTaskPriorityGet() API函数用于获取任务的优先级。该uxTaskPriorityGet() API函数仅在FreeRTOSConfig.h文件中将INCLUDE_uxTaskPriorityGet设置为1时可用。

```c
UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );
```

**pxTask**

​	The handle of the task whose priority is being queried (the subject task). See the pxCreatedTask parameter of the xTaskCreate() API function for information on how to obtain handles to tasks.

​	A task can query its own priority by passing NULL in place of a valid task handle

**Return value**

​	The priority currently assigned to the task being queried.

<img src="./手册笔记/image-20250525212602999.png" alt="image-20250525212602999" style="zoom:50%;" />



## 4.10 Deleting a Task

### 4.10.1 The vTaskDelete() API Function

​	vTaskDelete() API函数用于删除任务。该vTaskDelete() API函数仅在FreeRTOSConfig.h文件中将INCLUDE_vTaskDelete设置为1时可用。

​	 在运行时持续创建和删除任务并非良好实践，因此如果您发现自己需要此功能，请考虑其他设计方案，例如复用任务(以暂时不适用函数的方式，如挂起/释放)。

​	被删除的任务不再存在，并且不能再进入运行态。

​	如果某个使用动态内存分配创建的任务随后自行删除，空闲任务将负责释放已分配的内存，例如被删除任务的数据结构和栈。因此在这种情况下，应用程序绝不能占用空闲任务的所有处理时间，这一点至关重要。

​	当任务被删除时，只有内核自身分配给该任务的内存会自动释放(TCB 和 栈)。任务实现过程中分配的任何内存或其他资源 (如程序运行中主动创建的数组，和全局变量)，若不再需要，必须显式释放。

```c
void vTaskDelete( TaskHandle_t xTaskToDelete );
```

**vTaskDelete() parameters**

​	The handle of the task that is to be deleted (the subject task). See the pxCreatedTask parameter of the xTaskCreate() API function, and the return value of the xTaskCreateStatic() API function, for information on obtaining handles to tasks.

​	A task can delete itself by passing NULL in place of a valid task handle.

**注意：**如果一个任务删除它自己，那么，删除操作执行后，该任务将立即让出CPU，无法再次执行，并在空闲时释放内存。

<img src="./手册笔记/image-20250525214124660.png" alt="image-20250525214124660" style="zoom:50%;" />



## 4.11 Thread Local Storage and Reentrancy

​	线程本地存储 (Thread Local Storage) 允许应用开发者在每个任务的任务控制块中存储任意数据。该特性经常用于存储被不可重入函数 (non-reentrant functions) 存放在全局变量中的数据。

​	可重入函数是一种能够在多个线程中安全运行且不产生任何副作用的函数。当在没有线程本地存储（TLS）的多线程环境中使用非可重入函数时，必须特别注意在临界区（Critical Section）内检查这些函数调用的带外结果。过度使用临界区会降低实时操作系统性能，因此线程本地存储通常比临界区更受青睐。          

​	迄今为止，线程本地存储最常见的应用场景是ISO C标准中定义的errno全局变量，该变量在C标准库和POSIX系统中广泛使用。errno全局变量用于为strtof、strtol等常见标准库函数提供扩展结果或错误代码。

### 4.11.1 C Runtime Thread Local Storage Implementation

​	大多数嵌入式libc都提供了API以确保非可重入函数能在多线程环境中正确工作。freeRTOS支持两种常用开源库的可重入API：newlib和picolibc。这些预构建的C运行时线程本地存储实现可通过在项目的FreeRTOSConfig.h文件中定义下方列出的相应宏来启用:

```c
configUSE_NEWLIB_REENTRANT for newlib
configUSE_PICOLIBC_TLS for picolibc
```

### 4.11.2 Custom C Runtime Thread Local Storage

​	可通过在FreeRTOSConfig.h文件中定义以下宏来实现线程本地存储：

- 将配置项USE_C_RUNTIME_TLS_SUPPORT定义为1以启用C运行时线程本地存储支持。

- 将configTLS_BLOCK_TYPE定义为应用于存储C运行时线程本地存储数据的C语言类型。

- 将 `configTLS_BLOCK_TYPE` 定义为用于存储 C 运行时线程本地存储（Thread Local Storage, TLS）数据的 C 类型。	
- 将 `configINIT_TLS_BLOCK` 定义为初始化 C 运行时线程本地存储 (TLS) 块时应运行的 C 代码。
- 将 `configSET_TLS_BLOCK` 定义为切换新任务时应运行的 C 代码。
- 将 `configDEINIT_TLS_BLOCK` 定义为反初始化 C 运行时线程本地存储块时应运行的 C 代码。

### 4.11.3 Application Thread Local Storage

​	除了 C 运行时线程本地存储（TLS）之外，程序员还可以定义一组程序的特殊指针，以包含在任务控制块（TCB）中。此功能可通过在项目的 FreeRTOSConfig.h 文件中将**configNUM_THREAD_LOCAL_STORAGE_POINTERS**设置为非零值来启用。

​	下面定义的**vTaskSetThreadLocalStoragePointer**和**pvTaskGetThreadLocalStoragePointer**函数可分别用于在运行时设置和获取每个线程本地存储指针的值。

```c
void * pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, 
 											BaseType_t xIndex ) ;
void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, 
 									BaseType_t xIndex,  void * pvValue );
```

## 4.12 Scheduling Algorithms

### 4.12.1 任务状态与事件回顾

​	实际正在运行（占用处理器时间）的任务处于**运行态**。在单核处理器上，任意时刻只能有一个任务处于运行态。FreeRTOS 也支持在多核处理器上运行（即**非对称多处理，AMP**），或跨多个核心调度任务（即**对称多处理，SMP**），但本节暂不讨论这两种场景。

​	一个任务不是阻塞态、挂起态、运行态，那么它就处在就绪态。调度器能够选择处在就绪态的任务进入到运行态。并且，调度器总是从就绪态中先选择高优先级的任务进入运行态。

​	 任务可以在阻塞状态下等待某个事件，当事件发生时，它们会自动移回就绪状态。时间事件在特定时间发生，例如阻塞时间到期时，通常用于实现周期性行为或超时行为。同步事件则在任务或中断服务程序使用任务通知、队列、事件组、消息缓冲区、流缓冲区或多种类型的信号量之一发送信息时发生。它们通常用于通知异步活动，例如数据到达外设。

### 4.12.2 Selecting the Scheduling Algorithm

​	 在软件运行时，由调度器算法决定哪一个就绪状态的任务进入运行状态。

​	到目前位置，所有的案例中使用了相同的调度器算法，但是可以通过配置FreeRTOSConfig.h文件中的onfigUSE_PREEMPTION and configUSE_TIME_SLICING常量进行改变。

​	第三个配置常量 configUSE_TICKLESS_IDLE 也会影响调度器算法，因为使用该常量可能导致Tick中断在较长时间内完全关闭。configUSE_TICKLESS_IDLE 是专门为必须最小化功耗的应用程序提供的高级选项。本节提供的描述中，假定 configUSE_TICKLESS_IDLE 设置为 0，如果该常量未定义，这也是默认设置。

​	在所有可能的单核配置中，FreeRTOS调度器会轮流选择共享优先级的任务。这种"轮流执行**（Round Robin Scheduling）**"策略常被称为"轮转调度"。轮转调度算法并不保证同等优先级任务间的时间均等分配，仅确保就绪状态的同等优先级任务能依次进入运行状态。

<img src="./手册笔记/image-20250527192531589.png" alt="image-20250527192531589" style="zoom:67%;" />

-  高优先级任务可抢占低优先级任务，相同优先级任务按时间片轮流执行。configUSE_PREEMPTION 为 1 开启抢占功能，configUSE_TIME_SLICING 为 1 开启时间片功能。	
-  高优先级任务可抢占低优先级任务，但相同优先级任务不会按时间片轮流，而是先就绪的任务一直执行，直到其主动放弃 CPU 。configUSE_PREEMPTION 为 1 开启抢占，configUSE_TIME_SLICING 为 0 关闭时间片。
-  任务需主动放弃 CPU，不存在优先级抢占。configUSE_PREEMPTION 为 0 关闭抢占功能，configUSE_TIME_SLICING 值无影响 。

### 4.12.3 Prioritized Preemptive Scheduling with Time Slicing

​	下面所示的配置将FreeRTOS调度器设置为使用一种名为"固定优先级抢占式调度与时间片分割"的调度算法，这是大多数小型实时操作系统应用采用的调度算法，也是本书目前所有示例所使用的算法。下一张表格对该算法名称中使用的术语进行了说明。

**对用于描述调度策略的术语的解释 ：**

**Fixed Priority**

​	所谓“固定优先级”调度算法，就是 不会改变为正在调度的任务所分配的优先级，但也不会阻止任务自身去改变其自身或其他任务的优先级。 

**Preemptive**

​	抢占式调度算法规定，若进入就绪态的任务优先级高于当前处于运行态的任务，就会立即“抢占”该运行态任务。被抢占意味着非自愿地从运行态转移到就绪态（无需主动让出CPU或进入阻塞态 ），以便让其他任务进入运行态。任务抢占可在任何时刻发生，并非仅在实时操作系统的Tick中断时才会出现。 

**Time Slicing**

​	时间片调度用于在同等优先级的任务之间共享处理时间，即使这些任务未显式让出 CPU 或进入阻塞状态。所谓使用时间片调度的算法是指：如果存在与当前运行任务优先级相同的其他就绪态任务，调度器会在每个时间片结束时选择一个新任务进入运行态。一个时间片的时长等于两次 RTOS 系统Tick中断之间的时间间隔.

​	将太多的处理时间分配给空闲任务可能并不理想，如果程**序员创建的*空闲优先级*** (*用户创建的优先级为零的任务。为了防止冲突，将程序员手动创建的空闲任务用加粗斜体的方式表示*) 任务有工作要执行，而空闲任务却没有。可通过配置编译时常量configIDLE_SHOULD_YIELD来改变空闲任务的调度方式。

- 如果配置configIDLE_SHOULD_YIELD 为1，就绪状态中存在其它同等优先级的***空闲优先级任务***，那么空闲任务会在每次循环迭代时让出（自愿放弃其分配时间片的剩余部分）。

![image-20250527204457353](./手册笔记/image-20250527204457353.png)

- 如果配置configIDLE_SHOULD_YIELD 为0，那么与空闲任务同等优先级的任务都将与空闲任务通过时间片轮询的方式执行。

![image-20250527204444481](./手册笔记/image-20250527204444481.png)

### 4.12.4 Prioritized Preemptive Scheduling without Time Slicing

​	无时间分割的优先级抢占式调度方法 仍然保持和之前章节中相同的任务选择和抢占算法，但是同等优先级的任务没有使用时间片分割来分配处理时间。

​	能够在FreeRTOSConfig.h文件中配置FreeRTOS*使用无时间分割的优先级抢占式调度方法*。

​	如果使用了时间片分割，当有超过一个的更高优先级的任务处于就绪状态时 (能够运行)，那么调度器将在每个RTOS Tick 中断时 ( 一个中断标志着时间片的结束)，选择一个新的任务进入运行态。 如果不使用时间片调度，那么调度器仅在以下任一情况发生时才会选择新任务进入运行态：

- 一个更高优先级的任务进入就绪态。

- 处于运行态的任务进入阻塞态或挂起态。

​	不使用时间片分割与使用时间片分割相比，所使用的上下文切换将更少。因此，关闭时间片分割将减少调度器的处理开销。但是，关闭时间片分割将导致同等优先级的任务获得了巨大差异的处理时间。因此，在没有时间分片的情况下运行调度程序被视为一项高级技术，仅建议有经验的用户使用。

### 4.12.5 Cooperative Scheduling (整个程序原子性)

​	本书主要讨论抢占式调度，但FreeRTOS也可采用协作式调度。下面展示了通过FreeRTOSConfig.h配置文件将FreeRTOS调度器设置为协作式调度的相关参数。

​	当使用协作式调度器时（因此假设应用程序提供的中断服务例程不会显式请求上下文切换），上下文切换仅发生在运行状态任务进入阻塞状态时，或运行状态任务通过调用taskYIELD()显式让出（手动请求重新调度）时。任务永远不会被抢占，因此无法使用时间片轮转。

![image-20250527212421420](./手册笔记/image-20250527212421420.png)

​	在多任务应用程序中，程序员必须确保资源不会被多个任务同时访问，因为并发访问可能导致资源损坏。举例说明，假设被访问的资源是一个UART（串行端口）。两个任务向UART写入字符串：任务1写入"abcdefghijklmnop"，任务2写入"123456789"：

- 任务1处于运行状态并开始写入其字符串。它向UART写入"abcdefg"，但在继续写入更多字符前就退出了运行状态。

2. 任务2进入运行状态并向UART写入"123456789"，随后退出运行状态。
3. 任务1重新进入运行状态，将其字符串的剩余字符写入UART

​	在该场景下，实际写入UART的是"abcdefg123456789hijklmnop"。任务1写入的字符串并未如预期那样以连续不间断的序列写入UART，而是遭到了破坏，因为任务2写入UART的字符串穿插其中。

​	使用协作式调度器通常比使用抢占式调度器更容易避免由同时访问引发的问题[^7]。

[^7]: 本书后续章节将介绍任务间安全共享资源的方法。FreeRTOS系统自身提供的资源（如队列和信号量）始终可以安全地在任务间共享。

- 使用抢占式调度器时，运行状态的任务可能随时被抢占，包括当该任务与其他任务共享的资源处于不一致状态时。正如UART示例所示，让资源保持不一致状态可能导致数据损坏。

- 使用协作式调度器时，您能控制任务切换发生的时机。因此，您可以确保当某个资源处于不一致状态时，不会发生任务切换。

- 在上述UART示例中，您可以确保任务1在将整个字符串写入UART之前不会离开运行状态，从而消除该字符串被其他任务活动破坏的可能性。

​	如图4.22所示，使用协作式调度器会使系统响应速度低于采用抢占式调度器时的表现。

- 使用抢占式调度器时，一旦某个任务成为最高优先级的就绪态任务，调度器会立即启动该任务运行。这对于实时系统至关重要，这类系统必须在规定时间内响应高优先级事件。
- 而采用协作式调度器时，只有当正在运行的任务进入阻塞状态或调用taskYIELD()函数后，才会切换至已成为最高优先级就绪态的任务。



# 5 队列管理 (参考了中文手册)

## 5.1 介绍

​	“队列”提供了任务与任务之间、任务与中断之间以及中断与任务之间的通信机制。

### 5.5.1 概括

- 如何创建一个队列
- 队列如何管理其数据
- 如何向队列发送数据
- 如何从队列接收数据
- 队列阻塞是什么意思
- 往队列发送和从队列接收时，任务优先级会有什么样的影响

## 数据储存

​	 队列可以容纳有限数量的固定大小数据项[^8]。队列的能够容纳数据项的最大数量被称为'length'。在创建队列的时候可以指定队列的长度和其中每个数据项的大小。

​	[^8]FreeRTOS消息缓冲区 (详细描述在TBD章)，为队列提供了一种比队列更轻量级的选择，可用于存储可变长度的消息。

​	 队列通常被用作先进先出（FIFO）缓冲区，数据被写入队列的末端（尾部），并从队列的前端（头部）移除。下图展示了将队列用作FIFO时数据的写入和读取过程。此外，也可以向队列的前端写入数据，或覆盖队列前端已有的数据。

![image-20250528203148074](./手册笔记/image-20250528203148074.png)

![image-20250528203159078](./手册笔记/image-20250528203159078.png)

![image-20250528203205863](./手册笔记/image-20250528203205863.png)

队列行为的实现方式有两种： 

​	1.**按值复制队列**     按值复制是指将发送到队列的数据逐字节复制到队列中。

​	2.**按引用队列**     按引用队列是指队列仅保存指向发送数据的指针，而非数据本身。 

FreeRTOS采用按值复制的方式，因为它比按引用方式更强大且易用，原因如下： 

- **兼容性**：按值复制并不排除队列也能用于按引用方式。例如，当数据量过大导致复制不切实际时，可以将数据指针复制到队列中。 
- **临时变量支持**：即使栈变量在声明它的函数退出后不再存在，也可以直接将其发送到队列。
- **无需预分配内存**：可以直接将数据发送到队列，而无需预先分配缓冲区存储数据（之后再将数据复制到分配的缓冲区并将缓冲区引用入队）。 
-  **资源复用高效**：发送任务可以立即复用已发送到队列的变量或缓冲区。 -
- **任务解耦**：发送任务和接收任务完全解耦，应用设计者无需关心数据的“所有权”或释放责任。 
- **内存管理简化**：RTOS完全负责分配存储数据的内存。 
-  **内存保护兼容性**：在内存受保护的系统中，按引用队列要求发送和接收任务都能访问被引用的数据，而按值复制允许数据跨越内存保护边界传递。

**可被多任务存取**

​	队列是具有自己独立权限的内核对象，并不属于或赋予任何任务。所有任务都可以

向同一队列写入和读出。一个队列可能经常由多方写入，但很少被多方读出。

**读取队列时阻塞**

​	当某个任务试图读一个队列时，其可以指定一个阻塞超时时间。在这段时间中，如

果队列为空，该任务将保持阻塞状态以等待队列数据有效。当其它任务或中断服务例程

往其等待的队列中写入了数据，该任务将自动由阻塞态转移为就绪态。当等待的时间超

过了指定的阻塞时间，即使队列中尚无有效数据，任务也会自动从阻塞态转移为就绪态。

​	由于队列可以被多个任务读取，所以对单个队列而言，也可能有多个任务处于阻塞

状态以等待队列数据有效。这种情况下，一旦队列数据有效，只会有一个任务会被解除

阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级

相同，那么被解除阻塞的任务将是等待最久的任务。

**写队列时阻塞**

​	同读队列一样，任务也可以在写队列时指定一个阻塞超时时间。这个时间是当被写

队列已满时，任务进入阻塞态以等待队列空间有效的最长时间。

​	由于队列可以被多个任务写入，所以对单个队列而言，也可能有多个任务处于阻塞

状态以等待队列空间有效。这种情况下，一旦队列存在可用空间，就会有一个任务会被解除

阻塞，这个任务就是所有等待任务中优先级最高的任务。而如果所有等待任务的优先级

相同，那么被解除阻塞的任务将是等待最久的任务。

### **5.2.5 多个队列的阻塞**  

​	队列可以分组为集合，允许任务进入阻塞状态，以等待集合中任意队列有数据可用。第5.6节(从多个队列接收数据) 描述了队列集合的使用。

### 5.2.6 创建队列：静态创建和动态创建队列

​	队列在使用前必须先被创建。

​	队列由声明为 QueueHandle_t 的句柄变量进行引用。xQueueCreate()用于创建一个队列，并返回一个 xQueueHandle 句柄以便于对其创建的队列进行引用。

​	当创建队列时，FreeRTOS 从堆空间 (FreeRTOS堆)中分配内存空间。分配的空间用于存储队列数据结构本身以及队列中包含的数据单元。如果内存堆中没有足够的空间来创建队列，xQueueCreate()将返回 NULL。下面章节有关于内存堆管理的更多信息。

**xQueueLength**
	The maximum number of items that the queue being created can hold at any one time.
**uxItemSize**
	The size in bytes of each data item that can be stored in the queue.

**Return value**

​	如果返回NULL，则队列无法创建，因为FreeRTOS没有足够的堆内存来分配队列数据结构和存储区域。

​	如果返回非NULL值，则表示队列创建成功，返回值为所创建队列的句柄。

**xQueueReset()** 是一个API函数，用于将先前创建的队列恢复到初始的空状态。

### 5.3.2 xQueueSendToBack()与xQueueSendToFront() API函数

​	如同函数名字面意思所期望的一样，xQueueSendToBack()用于将数据发送到队列

尾；而 xQueueSendToFront()用于将数据发送到队列首。

​	xQueueSend()完全等同于 xQueueSendToBack()。

但切记**不要在中断服务例**程中调用 xQueueSendToFront() 或

xQueueSendToBack()。系统提供中断安全版本的 xQueueSendToFrontFromISR()与

xQueueSendToBackFromISR()用于在中断服务中实现相同的功能。

```c
BaseType_t xQueueSendToFront( QueueHandle_t xQueue, 
 							const void * pvItemToQueue, 
 							TickType_t xTicksToWait );
BaseType_t xQueueSendToBack( QueueHandle_t xQueue, 
							 const void * pvItemToQueue, 
 							TickType_t xTicksToWait );
```

**xQueueSendToFront()与 xQueueSendToBack()函数参数及返回值**

**Queue** 

​	目标队列的句柄。这个句柄即是调用 xQueueCreate()创建该队列时的返回值。

**pvItemToQueue** 

​	发送数据的指针。其指向将要复制到目标队列中的数据单元。由于在创建队列时设置了队列中数据单元的长度，所以会从该指针指向的空间复制对应长度的数据到队列的存储区域。

**xTicksToWait** 

​	阻塞超时时间。如果在发送时队列已满，这个时间即是任务处于阻塞态等待队列空间有效的最长等待时间。

​	如 果 xTicksToWait 设 为 0 ，并且队列已满，则xQueueSendToFront()与 xQueueSendToBack()均会立即返回。

​	阻塞时间是以系统心跳周期为单位的，所以绝对时间取决于系统心跳频率。常量 portTICK_RATE_MS 可以用来把心跳时间单位转换为毫秒时间单位。

**返回值**

- . pdPASS 

  返回 pdPASS 只会有一种情况，那就是数据被成功发送到队列中。如果设定了阻塞超时时间(xTicksToWait 非 0)，在函数返回之前任务将被转移到阻塞态以等待队列空间有效—在超时到来前能够将数据成功写入到队列，函数则会返回 pdPASS。

- errQUEUE_FULL 如果由于队列已满而无法将数据写入，则将返回errQUEUE_FULL。

​	如果设定了阻塞超时时间（xTicksToWait 非 0），在函数返回之前任务将被转移到阻塞态以等待队列空间有效。但直到超时也没有其它任务或是中断服务例程读取队列而腾出空间，函数则会返回 errQUEUE_FULL。

### 5.3.3 **xQueueReceive()**与 **xQueuePeek() API** **函数**

​	xQueueReceive()用于从队列中接收(读取）数据单元，**接收到的单元同时会从队列**

**中删除**。xQueuePeek()也是从从队列中接收数据单元，不同的是并**不从队列中删出接收到**的单元。xQueuePeek()从队列首接收到数据后，不会修改队列中的数据，也不会改变数据在队列中的存储序顺。切记不要在中断服务例程中调用 xQueueRceive()和 xQueuePeek()。中断安全版本的替代 API 函数 xQueueReceiveFromISR()将会在第三章中讲述。

​	

```c
portBASE_TYPE xQueueReceive( xQueueHandle xQueue, 
							const void * pvBuffer, 
							portTickType xTicksToWait ); 
portBASE_TYPE xQueuePeek( xQueueHandle xQueue, 
							const void * pvBuffer, 
							portTickType xTicksToWait );
```

**xQueue** 

​	被读队列的句柄。这个句柄即是调用 xQueueCreate()创建该队列时的返回值。

**pvBuffer** 

​	接收缓存指针。其指向一段内存区域，用于接收从队列中拷贝来的数据。数据单元的长度在创建队列时就已经被设定，所以该指针指向的内存区域大小应当足够保存一个数据单元。

**xTicksToWait** 

​	阻塞超时时间。如果在接收时队列为空，则这个时间是任务处于塞状态以等待队列数据有效的最长等待时间。如果 xTicksToWait 设为 0，并且队列为空，则 xQueueRecieve()

与 xQueuePeek()均会立即返回。阻塞时间是以系统Tick周期为单位的，所以绝对时间取决于系统Tick频率。常量 portTICK_RATE_MS 可以用来把Tick时间单位转换为毫秒时间单位。如果把 xTicksToWait 设置为 portMAX_DELAY ，并且在FreeRTOSConig.h 中设定 INCLUDE_vTaskSuspend 为 1，那么阻塞等待将没有超时限制。

**返回值**

有两个可能的返回值: 

- pdPASS 

只有一种情况会返回 pdPASS，那就是成功地从队列中读到数据。如果设定了阻塞超时时间(xTicksToWait 非 0)，在函数返回之前任务将被转移到阻塞态以等待队列数据有效—在超时到来前能够从队列中成功读取数据，函数则会返回 pdPASS。

- errQUEUE_FULL 

如果在读取时由于队列已空而没有读到任何数据，则将返回errQUEUE_FULL。如果设定了阻塞超时时间（xTicksToWait 非 0），在函数返回之前任务将被转移到阻塞态以等待队列数据有效。但直到超时也没有其它任务或是中断服务例程往队列中写入数据，函数则会返回errQUEUE_FULL

### 5.3.4 **uxQueueMessagesWaiting() API** **函数**

​	uxQueueMessagesWaiting()用于查询队列中当前有效数据单元个数。切记不要在中断服务例程中调用 uxQueueMessagesWaiting()。应当在**中断服务中使用其中断安全版本** uxQueueMessagesWaitingFromISR()。

```c
UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );
```

**xQueue** 

​	被查询队列的句柄。这个句柄即是调用 xQueueCreate()创建该队列时的返回值。

**返回值** 

​	当前队列中保存的数据单元个数。返回 0 表明队列为空。

### 案例

​	本示例演示了如何创建队列、从多个任务向队列发送数据以及从队列接收数据。该队列用int32_t类型存储数据项。向队列发送数据的任务未指定阻塞时间，而从队列接收数据的任务设置了阻塞时间。

​	其中，往队列中写数据的任务的优先级低于读队列任务的优先级。这意味着队列中永远不

会包含超过一个的数据单元。因为数据一旦写入队列，读队列任务立即解除阻塞，抢占写队列任务，并从队列中接收数据，同时数据从队列中删除，队列再一次变为空队列。

```c
static void vSenderTask( void *pvParameters )
{ 
 int32_t lValueToSend; 
 BaseType_t xStatus; 
 /* Two instances of this task are created so the value that is sent to
 the queue is passed in via the task parameter - this way each instance 
 can use a different value. The queue was created to hold values of type 
 int32_t, so cast the parameter to the required type. */
 lValueToSend = ( int32_t ) pvParameters; 
 /* As per most tasks, this task is implemented within an infinite loop. */
 for( ;; ) 
 { 
 /* Send the value to the queue. 
 The first parameter is the queue to which data is being sent. The
 queue was created before the scheduler was started, so before this 
 task started to execute. 
 The second parameter is the address of the data to be sent, in this 
 case the address of lValueToSend. 
 The third parameter is the Block time – the time the task should be 
 kept in the Blocked state to wait for space to become available on 
 the queue should the queue already be full. In this case a block 
 time is not specified because the queue should never contain more 
 than one item, and therefore never be full. */
 xStatus = xQueueSendToBack( xQueue, &lValueToSend, 0 ); 
 if( xStatus != pdPASS ) 
 { 
 /* The send operation could not complete because the queue was full-
 this must be an error as the queue should never contain more than
 one item! */
 vPrintString( "Could not send to the queue.\r\n" ); 
 } 
 }
    
    
    static void vReceiverTask( void *pvParameters )
{ 
 /* Declare the variable that will hold the values received from the
 queue. */
 int32_t lReceivedValue; 
 BaseType_t xStatus; 
 const TickType_t xTicksToWait = pdMS_TO_TICKS( 100 ); 
 /* This task is also defined within an infinite loop. */
 for( ;; ) 
 { 
 /* This call should always find the queue empty because this task will
 immediately remove any data that is written to the queue. */
 if( uxQueueMessagesWaiting( xQueue ) != 0 ) 
 { 
 vPrintString( "Queue should have been empty!\r\n" ); 
 } 
 /* Receive data from the queue. 
 The first parameter is the queue from which data is to be received.
 The queue is created before the scheduler is started, and therefore
 before this task runs for the first time. 
 The second parameter is the buffer into which the received data will
 be placed. In this case the buffer is simply the address of a 
 variable that has the required size to hold the received data.
 The last parameter is the block time – the maximum amount of time 
 that the task will remain in the Blocked state to wait for data to 
 be available should the queue already be empty. */
 xStatus = xQueueReceive( xQueue, &lReceivedValue, xTicksToWait );
 if( xStatus == pdPASS ) 
 { 
 /* Data was successfully received from the queue, print out the 
 received value. */
 vPrintStringAndNumber( "Received = ", lReceivedValue ); 
 } 
 else
 { 
 /* Data was not received from the queue even after waiting for 
 100ms. This must be an error as the sending tasks are free 
 running and will be continuously writing to the queue. */
 vPrintString( "Could not receive from the queue.\r\n" ); 
 } 
Mastering the FreeRTOS Real Time Kernel 94
 } 
}
    
    
    
    //其在启动调度器之前创建了一个队列和三
//个任务。尽管对任务的优先级的设计使得队列实际上在任何时候都不可能多于一个数据
//单元，本例代码还是创建了一个可以保存最多 5 个 long 型值的队列
    * Declare a variable of type QueueHandle_t. This is used to store the
 handle to the queue that is accessed by all three tasks. */
QueueHandle_t xQueue; 
int main( void )
{ 
 /* The queue is created to hold a maximum of 5 values, each of which is
 large enough to hold a variable of type int32_t. */
 xQueue = xQueueCreate( 5, sizeof( int32_t ) ); 
 if( xQueue != NULL ) 
 { 
 /* Create two instances of the task that will send to the queue. The
 task parameter is used to pass the value that the task will write 
 to the queue, so one task will continuously write 100 to the queue 
 while the other task will continuously write 200 to the queue. Both
 tasks are created at priority 1. */
 xTaskCreate( vSenderTask, "Sender1", 1000, ( void * ) 100, 1, NULL ); 
 xTaskCreate( vSenderTask, "Sender2", 1000, ( void * ) 200, 1, NULL ); 
 /* Create the task that will read from the queue. The task is created
 with priority 2, so above the priority of the sender tasks. */
 xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL ); 
 /* Start the scheduler so the created tasks start executing. */
 vTaskStartScheduler(); 
 } 
 else
 { 
 /* The queue could not be created. */
 } 
 /* If all is well then main() will never reach here as the scheduler will
 now be running the tasks. If main() does reach here then it is likely
 that there was insufficient FreeRTOS heap memory available for the idle 
 task to be created. Chapter 3 provides more information on heap memory 
 management. */
 for( ;; ); 
}
```

![image-20250528232549434](./手册笔记/image-20250528232549434.png)



## 5.4 Receiving Data From Multiple Sources

​	在FreeRTOS设计中，一个任务通常会从多个来源接收数据。接收任务需要知道数据的来源，以便确定如何处理这些数据。实现这一功能的一种简单设计模式是使用一个单独的队列来传输包含数据值和数据来源的结构体。如下图所示

![image-20250528233017387](./手册笔记/image-20250528233017387.png)

-	 他创建了一个用于存储Data_t类型结构体的队列。该结构体允许在一条消息中同时发送一个数据值和一个指示数据含义的枚举类型。  
-	 一个中央控制器任务执行系统的主要功能，它必须对队列中传递的输入和系统状态变化做出反应。   
-	CAN总线任务用于封装CAN总线接口功能。当CAN总线任务接收到并解码一条消息后，会以Data_t结构体的形式将已解码的消息发送给控制器任务。传输结构体中的eDataID成员告知控制器任务该数据的类型，在所示案例中，该数据为电机转速值；lDataValue成员则告知控制器任务实际的电机转速值。   
-	人机接口（HMI）任务用于封装所有HMI功能。机器操作员可能通过多种方式输入命令和查询值，这些操作需要在HMI任务中进行检测和解析。当输入新命令时，HMI任务会以Data_t结构体的形式将命令发送给控制器任务。传输结构体中的eDataID成员告知控制器任务该数据的类型，在所示案例中，该数据为新的设定值；lDataValue成员则告知控制器任务实际的设定值。

### 案例

​	  最低优先级的读取任务，高优先级的写入操作，且创建队列长度为3。

​	案例详情见手册 Example5.2

## 5.5 Working with Large or Variable Sized Data

​	如果队列存储的数据单元尺寸较大，那最好是利用队列来传递数据的指针而不是对数据本身在队列上一字节一字节地拷贝进或拷贝出。传递指针无论是在处理速度上还是内存空间利用上都更有效。但是，当你利用队列传递指针时，一定要十分小心以下两点：

- 指针所指向的 RAM 的所有者是明确定义的。

​	当通过指针在任务之间**共享内存**时，必须确保两个任务不同时修改内存内容，或采取任何其他可能导致内存内容无效或不一致的操作。理想情况下，在指针被发送到队列之前，应仅允许发送任务访问该内存；在指针从队列接收之后，应仅允许接收任务访问该内存。

- 指针指向的内存必须是有效的

​	 如果指针指向的内存是动态分配的，或从预分配缓冲区池中获取的，则必须仅有一个任务负责释放该内存。任何任务均不得在内存释放后尝试访问该内存。

​	 绝不应使用指针访问在任务栈上分配的数据。在栈任务更改(任务切换，栈空间被释放)后，该数据将不再有效。

### 5.5.2 Using a Queue to Send Different Types and Lengths of Data[^9]

​	[^9] **FreeRTOS消息缓冲区是队列的一种轻量级替代方案，用于存储可变长度的数据**。

​	 本书前面的章节展示了两种强大的设计模式：将结构体发送到队列，以及将指针发送到队列。结合这些技术可使一个任务通过单个队列接收来自任意数据源的任意数据类型。FreeRTOS+TCP TCP/IP 栈的实现提供了一个如何实现这一点的实际示例。  

​	 运行在其自身任务中的 TCP/IP 栈必须处理来自许多不同源的事件。不同的事件类型与不同类型和长度的数据相关联。IPStackEvent_t 结构体描述了发生在 TCP/IP 任务之外的所有事件，并通过队列发送到 TCP/IP 任务。

​	下面 展示了 IPStackEvent_t 结构体。IPStackEvent_t 结构体的 pvData 成员是一个指针，可用于直接保存一个值，或指向一个缓冲区。

```c
/* A subset of the enumerated types used in the TCP/IP stack to 
 identify events. */
typedef enum
{ 
 eNetworkDownEvent = 0, /* The network interface has been lost, or needs 
 (re)connecting. */
 eNetworkRxEvent, /* A packet has been received from the network. */
 eTCPAcceptEvent, /* FreeRTOS_accept() called to accept or wait for a 
 new client. */
/* Other event types appear here but are not shown in this listing. */
} eIPEvent_t; 
/* The structure that describes events, and is sent on a queue to the
 TCP/IP task. */
typedef struct IP_TASK_COMMANDS
{ 
 /* An enumerated type that identifies the event. See the eIPEvent_t
 definition above. */
 eIPEvent_t eEventType; 
 /* A generic pointer that can hold a value, or point to a buffer. */
 void *pvData; 
} IPStackEvent_t;

```

Example TCP/IP events, and their associated data, include:

**eNetworkRxEvent**: A packet of data was received from the network.

​	 网络接口使用IPStackEvent_t类型的结构体向TCP/IP任务发送数据接收事件。该结构体的eEventType成员被设置为eNetworkRxEvent，其pvData成员用于指向包含接收数据的缓冲区。

​	换句话说，利用队列的方式处理可变长度数据时，利用 结构体中 void *pvData，该任意类型的指针可以指向任何类型的数据，以此来访问不同长度的数据。

```c
typedef struct {
    void *data;  // 指向可变长度数据的指针
    size_t length;  // 数据长度
} VariableLengthData_t;

// 创建队列
QueueHandle_t queue = xQueueCreate(10, sizeof(VariableLengthData_t));

// 发送数据
void sendData(void *pvParameters) {
    char *message = "Hello, FreeRTOS!"; // 可变长度数据
    VariableLengthData_t data = { message, strlen(message) + 1 };
    xQueueSend(queue, &data, portMAX_DELAY);
}

// 接收数据
void receiveData(void *pvParameters) {
    VariableLengthData_t data;
    if (xQueueReceive(queue, &data, portMAX_DELAY)) {
        printf("Received: %s, Length: %d\n", (char *)data.data, data.length);
    }
}
```



**考虑到对于可变长度数据处理有更好的方式----信息缓冲区、流缓冲区，这里不在复述其他案例**

## 5.6 Receiving From Multiple Queues

### 5.6.1 Queue sets (非必要不使用)

​	 通常，应用程序设计需要单个任务接收不同大小、不同含义和来自不同数据源的数据。前一节演示了如何使用接收结构体的单个队列，以简洁高效的方式实现这一点。然而，有时应用程序设计人员仍然面临限制，因此需要为某些数据源使用单独的队列。例如，集成到设计中的第三方代码可能需要存在专用队列。在这种情况下，可以使用“队列集”。	

​	队列集允许任务从多个队列接收数据，而无需任务依次轮询每个队列来确定哪些队列（如果有的话）包含数据。

​	采用队列集从多个来源接收数据的设计方案，其**简洁性和效率均逊色于使用单一队列接收结构体实现相同功能的设计。因此建议仅在设计约束使其使用成为绝对必要时才采用队列集方案。**

![image-20250529210412480](./手册笔记/image-20250529210412480.png)

## 5.7 Using a Queue to Create a Mailbox

**可以用二值信号量等方式替**

​	嵌入式领域对术语尚未达成统一共识，"Mailbox"在不同实时操作系统中具有不同含义。本书中，"Mailbox"特指长度为1的队列。某个队列可能因其在应用程序中的使用方式（而非功能上与队列存在差异）而被描述为Mailbox。

- 队列用于将数据从一个任务发送到另一个任务，或从中断服务程序发送到任务。发送方将数据项放入队列，接收方从队列中取出并从队列中删除数据项，数据通过队列从发送方传递到接收方。   

- Mailbox用于保存可被任何任务或中断服务程序读取的数据。数据不会穿过Mailbox传递，而是保留在Mailbox中直至被覆盖。发送方会覆盖Mailbox中的值，接收方从Mailbox中读取值，但不会从Mailbox中删除该值。

**The xQueueOverwrite() API Function**

​	 与`xQueueSendToBack()` API函数一样，`xQueueOverwrite()` API函数也用于向队列发送数据。但与`xQueueSendToBack()`不同的是，如果队列已满，`xQueueOverwrite()`会直接覆盖队列中已有的数据。  

​	 `xQueueOverwrite()`只能用于长度为1的队列。覆盖模式始终会向队列前端写入数据并更新队列前端指针，但不会更新等待的消息数。如果定义了`configASSERT`，当队列长度大于1时会触发assert。



#  6 Software Timer Management

## 6.1 Chapter Introduction and Scope

​	 软件定时器用于在未来的设定时间或按固定频率定期调度函数的执行。由软件定时器执行的函数称为软件定时器的回调函数。

​	软件定时器由FreeRTOS内核实现并受其控制，它不需要硬件支持，且与硬件定时器或硬件计数器无关。   

​	根据FreeRTOS通过创新设计确保最高效率的理念，除非软件定时器的回调函数实际正在执行，否则软件定时器不会占用任何处理时间。

软件定时器功能是可选的。若要启用该功能，需完成以下配置： 

1. 将FreeRTOS源码文件 `FreeRTOS/Source/timers.c` 纳入项目编译。 

2. 在应用程序的 `FreeRTOSConfig.h` 头文件中定义以下常量：

   ```c
   /* 启用软件定时器功能 */
   #define configUSE_TIMERS                1
   
   /* 设置定时器服务任务优先级（范围：0 至 configMAX_PRIORITIES-1） */
   #define configTIMER_TASK_PRIORITY       3
   
   /* 设置定时器命令队列的最大未处理命令数 */
   #define configTIMER_QUEUE_LENGTH        10
   
   /* 设置定时器服务任务的堆栈深度（单位：字，非字节） */
   #define configTIMER_TASK_STACK_DEPTH    256
   ```
